{"version":3,"file":"index.umd.js","sources":["../src/axis.ts","../src/label.ts","../src/labels.ts","../src/graduations.ts","../src/container.ts","../src/axes.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\nexport interface AxisParameters {\n  size: number\n  labels: (number | string)[]\n  decimals?: number\n  prefix: string\n  suffix: string\n  graduations: number\n  root: boolean\n  relative: boolean\n  lineWidth: number\n  progress: number\n  margin: number\n  padding: number\n  distance: number\n}\n\nexport interface AxisGenerateParameters {\n  targetDensity: number\n  minimumDelta: number\n  rounding: number\n  avoidPrime: boolean\n  includeZero: boolean\n  autoRelative: boolean\n  symmetric: boolean\n  minimumOffset: number\n  maximumOffset: number\n}\n\nexport class Axis implements AxisParameters {\n  private _relative!: boolean\n  private _labels!: (number | string)[]\n  public orientation: Vector2\n  public spacing: Vector2\n  public size: number\n  public decimals?: number\n  public prefix: string\n  public suffix: string\n  public graduations: number\n  public root: boolean\n  public lineWidth: number\n  public progress: number\n  public margin: number\n  public padding: number\n  public distance: number\n  public rootPosition!: number\n  public startOffset: number = 0\n  public endOffset: number = 0\n\n  public constructor({\n    orientation,\n    spacing,\n    size = 10,\n    labels = [],\n    prefix = '',\n    suffix = '',\n    decimals = undefined,\n    graduations = 1,\n    root = false,\n    relative = false,\n    lineWidth = 0.02,\n    progress = 1,\n    margin = 0.2,\n    padding = 0,\n    distance = 0\n  }: Partial<AxisParameters> & {\n    orientation: Vector2\n    spacing: Vector2\n  }) {\n    this.orientation = orientation\n    this.spacing = spacing\n    this.size = size\n    this._labels = labels\n    this.prefix = prefix\n    this.suffix = suffix\n    this.decimals = decimals\n    this.graduations = graduations\n    this.root = root\n    this.relative = relative\n    this.lineWidth = lineWidth\n    this.progress = progress\n    this.margin = margin\n    this.padding = padding\n    this.distance = distance\n  }\n\n  private isPrime(number: number): boolean {\n    for (var i = 2, s = Math.sqrt(number); i <= s; i++) {\n      if (number % i === 0) return false\n    }\n\n    return number > 1\n  }\n\n  private adjustDelta(\n    delta: number,\n    minimumDelta: number,\n    range: number,\n    targetDensity: number\n  ): number {\n    const halfRange = range / 2\n    delta = Math.max(minimumDelta, delta)\n    delta *= range / delta / targetDensity\n    return delta >= halfRange ? halfRange : delta\n  }\n\n  private updateRootPosition(): void {\n    if (!this.relative) {\n      this.rootPosition = 0\n    } else if (!this.labels.length) {\n      this.rootPosition = 0.5\n    } else {\n      const index = this.labels.findIndex(label => (\n        parseFloat(label as string) === 0\n      ))\n\n      this.rootPosition = index === -1\n        ? 0\n        : index / (this.labels.length - 1)\n    }\n  }\n\n  public get labels(): (number | string)[] {\n    return this._labels\n  }\n\n  public set labels(labels: (number | string)[]) {\n    this._labels = labels\n    this.updateRootPosition()\n  }\n\n  public get relative(): boolean {\n    return this._relative\n  }\n\n  public set relative(relative: boolean) {\n    this._relative = relative\n    this.updateRootPosition()\n  }\n\n  public generate(values: number[], {\n    targetDensity = 4,\n    minimumDelta = 1,\n    rounding = 2,\n    avoidPrime = true,\n    includeZero = false,\n    autoRelative = true,\n    minimumOffset = 0,\n    maximumOffset = 0,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    symmetric = false // TODO\n  }: Partial<AxisGenerateParameters> = {}): void {\n    this.reset()\n\n    let minimum = Infinity\n    let maximum = -Infinity\n    let baseDelta = Infinity\n    let startOffset = 0\n    let endOffset = 0\n    let round = (value: number): number => value\n\n    values.forEach((value) => {\n      if (value < minimum) minimum = value\n      if (value > maximum) maximum = value\n\n      values.forEach((otherValue) => {\n        const valueDelta = Math.abs(value - otherValue)\n        if (valueDelta && valueDelta < baseDelta) baseDelta = valueDelta\n      })\n    })\n\n    minimum -= minimumOffset\n    maximum += maximumOffset\n\n    let range = maximum - minimum\n    let delta = this.adjustDelta(\n      baseDelta,\n      minimumDelta,\n      range,\n      targetDensity\n    )\n\n    if (autoRelative) this.relative = minimum < 0 && maximum > 0\n\n    if (rounding !== undefined) {\n      const roundingFactor = Math.pow(10, rounding)\n      round = (value: number) => Math.round(\n        value * roundingFactor\n      ) / roundingFactor\n\n      let shiftedMinimum = ~~(\n        minimum * roundingFactor\n      ) / roundingFactor\n\n      shiftedMinimum !== minimum && minimum--\n      startOffset += minimum - shiftedMinimum\n      minimum = shiftedMinimum\n      range += startOffset\n      delta = round(this.adjustDelta(\n        baseDelta,\n        minimumDelta,\n        range,\n        targetDensity\n      ))\n    }\n\n    const baseAmount = range / delta + 1\n    let amount = Math.ceil(baseAmount)\n\n    if (avoidPrime) {\n      while (this.isPrime(amount + 1)) amount++\n    }\n\n    endOffset = (amount - baseAmount) * delta || 0\n    maximum += endOffset\n    range += endOffset\n\n    if (includeZero || (autoRelative && this.relative)) {\n      let relativeOffset = Infinity\n\n      for (var i = 0; relativeOffset && i < amount; i++) {\n        const value = minimum + i * delta\n        if (Math.abs(value) < Math.abs(relativeOffset)) relativeOffset = value\n      }\n\n      if (relativeOffset < 0) relativeOffset += delta\n\n      minimum -= relativeOffset\n      startOffset += relativeOffset\n      range += relativeOffset\n      delta = round(this.adjustDelta(\n        baseDelta,\n        minimumDelta,\n        range,\n        targetDensity\n      ))\n    }\n\n    const labels: number[] = []\n\n    for (var i = 0; i < amount; i++) {\n      labels.push(round(minimum + i * delta))\n    }\n\n    this.startOffset = startOffset / range\n    this.endOffset = endOffset / range\n    this.labels = labels\n  }\n\n  public reset(): void {\n    this.startOffset = this.endOffset = 0\n    this.labels.splice(0)\n    this.root = false\n    this.relative = false\n  }\n}\n","import { CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer'\nimport { Axis } from '~/axis'\n\nexport class Label extends CSS3DObject {\n  private readonly wrapper: HTMLDivElement = document.createElement('div')\n  private readonly content: HTMLDivElement = document.createElement('div')\n\n  public constructor() {\n    super(document.createElement('div'))\n    this.wrapper.appendChild(this.content)\n    this.element.appendChild(this.wrapper)\n  }\n\n  public get style(): CSSStyleDeclaration {\n    return this.wrapper.style\n  }\n\n  public generate(axis: Axis, value: number | string): void {\n    const rounding = (\n      axis.decimals !== undefined &&\n      Math.pow(10, axis.decimals)\n    ) as number\n\n    this.content.textContent = `${axis.prefix}${\n      rounding ? Math.round((value as number) * rounding) / rounding : value\n    }${axis.suffix}`\n  }\n\n  public resize(\n    axis: Axis,\n    opposite: Axis,\n    position: number,\n    renderingScale: number = 10\n  ): void {\n    const oppositeRelative = !!opposite.rootPosition as unknown as number\n    const rootPosition = (opposite.rootPosition - 0.5) * opposite.size\n    position = (position / (axis.labels.length - 1) - 0.5) * axis.size\n\n    const spacingX = axis.spacing.x * (\n      (oppositeRelative || !axis.orientation.x) as unknown as number\n    )\n\n    const spacingY = axis.spacing.y * (\n      (oppositeRelative || !axis.orientation.y) as unknown as number\n    )\n\n    this.content.style.transform = `translate(${\n      50 * spacingX\n    }%, ${\n      -50 * spacingY\n    }%)`\n\n    this.position\n      .setX(renderingScale * (\n        axis.orientation.x * position +\n        axis.orientation.y * rootPosition +\n        axis.margin * spacingX -\n        axis.padding * axis.orientation.y * (1 - oppositeRelative)\n      ))\n      .setY(renderingScale * (\n        axis.orientation.y * position +\n        axis.orientation.x * rootPosition +\n        axis.margin * spacingY -\n        axis.padding * axis.orientation.x * (1 - oppositeRelative)\n      ))\n      .setZ(axis.distance * renderingScale)\n  }\n}\n","import { Object3D, Camera, Scene, Matrix4 } from 'three'\nimport { CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer'\nimport { Axis } from '~/axis'\nimport { Label } from '~/label'\n\nexport interface LabelsParameters {\n  opacity: number\n  color: string\n  fontSize: number\n  fontFamily: string\n  faceCamera: boolean\n  renderingScale: number\n}\n\nexport class Labels extends Object3D implements LabelsParameters {\n  private readonly css3DRenderer = new CSS3DRenderer()\n  private readonly originalMatrix = new Matrix4()\n  private _faceCamera!: boolean\n  public readonly style = this.css3DRenderer.domElement.style\n  public fontSize: number\n  public renderingScale: number\n\n  public constructor({\n    opacity = 1,\n    color = '#ffffff',\n    fontSize = 0.3,\n    fontFamily = 'sans-serif',\n    faceCamera = false,\n    renderingScale = 100,\n  }: Partial<LabelsParameters> = {}) {\n    super()\n\n    this.opacity = opacity\n    this.color = color\n    this.fontSize = fontSize\n    this.fontFamily = fontFamily\n    this.faceCamera = faceCamera\n    this.renderingScale = renderingScale\n    this.matrixAutoUpdate = false\n\n    this.style.position = 'absolute'\n    this.style.pointerEvents = 'none'\n    this.style.top =\n    this.style.left = '0'\n    this.style.zIndex = '2'\n\n    document.body.appendChild(this.css3DRenderer.domElement)\n  }\n\n  private iterate(x: Axis, y: Axis, callback: (\n    axis: Axis,\n    opposite: Axis,\n    index: number,\n    position: number,\n    value: number | string\n  ) => void): number {\n    return [x, y].reduce((index, axis, axisIndex, axes) => {\n      return axis.labels.reduce((index: number, value, position) => {\n        callback(\n          axis,\n          axes[(axisIndex + 1) % axes.length],\n          index,\n          position,\n          value\n        )\n\n        return index + 1\n      }, index)\n    }, 0)\n  }\n\n  private scaleFont(): void {\n    this.style.fontSize = `${this.fontSize * this.renderingScale}px`\n  }\n\n  public get opacity(): number {\n    return parseFloat(this.style.opacity!)\n  }\n\n  public set opacity(opacity: number) {\n    this.style.opacity = opacity as unknown as string\n  }\n\n  public get color(): string {\n    return this.style.color!\n  }\n\n  public set color(color: string) {\n    this.style.color = color\n  }\n\n  public get fontFamily(): string {\n    return this.style.fontFamily!\n  }\n\n  public set fontFamily(fontFamily: string) {\n    this.style.fontFamily = fontFamily\n  }\n\n  public get faceCamera(): boolean {\n    return this._faceCamera\n  }\n\n  public set faceCamera(faceCamera: boolean) {\n    this._faceCamera = faceCamera\n    faceCamera || this.children.forEach(label => label.rotation.set(0, 0, 0))\n  }\n\n  public get visible(): boolean {\n    return this.style ? this.style.display !== 'none' : true\n  }\n\n  public set visible(visible: boolean) {\n    if (this.style) this.style.visibility = visible ? null : 'none'\n  }\n\n  public setRendererSize(width: number, height: number): void {\n    this.css3DRenderer.setSize(width, height)\n  }\n\n  public render(camera: Camera): void {\n    const parent = this.parent\n    const xCamera = camera.position.x\n    const yCamera = camera.position.y\n    const zCamera = camera.position.z\n\n    this.originalMatrix.copy(this.matrix)\n    this.parent = null\n\n    camera.position.multiplyScalar(this.renderingScale)\n\n    this.updateWorldMatrix(true, false)\n    parent!.updateWorldMatrix(true, false)\n    this.applyMatrix(parent!.matrixWorld)\n    this.updateWorldMatrix(false, false)\n\n    this.faceCamera && this.children.forEach(label => {\n      label.lookAt(camera.position)\n    })\n\n    this.position.multiplyScalar(this.renderingScale)\n    this.updateMatrix()\n    this.updateMatrixWorld(true)\n\n    this.css3DRenderer.render(this as unknown as Scene, camera)\n\n    camera.position.set(xCamera, yCamera, zCamera)\n\n    this.parent = parent\n    this.matrix.copy(this.originalMatrix)\n    this.matrix.decompose(this.position, this.quaternion, this.scale)\n  }\n\n  public generate(x: Axis, y: Axis): void {\n    this.scaleFont()\n\n    this.children\n      .slice(this.iterate(x, y, (axis, opposite, index, position, value) => {\n        let label = this.children[index] as Label\n        label || this.add(label = new Label())\n        label.generate(axis, value)\n        label.resize(axis, opposite, position, this.renderingScale)\n      }))\n      .forEach(label => this.remove(label))\n  }\n\n  public resize(x: Axis, y: Axis): void {\n    this.scaleFont()\n\n    this.iterate(x, y, (axis, opposite, index, position) => {\n      const label = this.children[index] as Label\n      label && label.resize(axis, opposite, position, this.renderingScale)\n    })\n  }\n}\n","import { BufferGeometry, BufferAttribute } from 'three'\nimport { Axis } from '~/axis'\n\nexport class Graduations extends BufferGeometry {\n  private graduations: number[] = []\n\n  public generate(x: Axis, y: Axis): void {\n    const indicesLength = 6 * [x, y].reduce((sum, {\n      graduations,\n      root,\n      rootPosition,\n      labels\n    }, index) => {\n      const maximum = labels.length - 1\n\n      if (!graduations) {\n        graduations = 0 + (root as unknown as number)\n      } else if (labels.length) {\n        if (graduations < 1) {\n          rootPosition *= maximum\n          let step = Math.min(maximum, Math.round(1 / graduations))\n          while (maximum % step || rootPosition % step) step--\n          graduations = Math.ceil(labels.length / step)\n        } else {\n          graduations = Math.round(graduations) * maximum + 1\n        }\n      } else {\n        graduations = Math.round(graduations)\n      }\n\n      this.graduations[index] = graduations\n\n      return sum + graduations\n    }, 0)\n\n    const indices = new Uint16Array(indicesLength)\n    let index = 0\n\n    for (var i = 0; i < indicesLength; i += 6) {\n      indices[i    ] = indices[i + 3] = index\n      indices[i + 1] = indices[i + 5] = index + 2\n      indices[i + 2] = index + 1\n      indices[i + 4] = index + 3\n\n      index += 4\n    }\n\n    this.setIndex(new BufferAttribute(indices, 1))\n    this.setAttribute('position',\n      new BufferAttribute(new Float32Array(indicesLength * 2), 3)\n    )\n\n    this.resize(x, y)\n  }\n\n  public resize(x: Axis, y: Axis): void {\n    const positionAttribute = this.getAttribute('position') as BufferAttribute\n    const vertices = positionAttribute.array as Float32Array\n\n    const xGraduations = this.graduations[0]\n    const yGraduations = this.graduations[1]\n\n    const xHalfSize = x.size / 2\n    const yHalfSize = y.size / 2\n\n    const xFactor = x.size / Math.max(1, xGraduations - 1)\n    const yFactor = y.size / Math.max(1, yGraduations - 1)\n\n    const xHalfPaddedSize = xHalfSize + y.padding\n    const yHalfPaddedSize = yHalfSize + x.padding\n\n    const xHalfLineWidth = x.lineWidth / 2\n    const yHalfLineWidth = y.lineWidth / 2\n\n    const xHalfOuterSize = xHalfPaddedSize + xHalfLineWidth\n    const yHalfOuterSize = yHalfPaddedSize + yHalfLineWidth\n\n    const xRootPosition = xGraduations === 1 ? x.rootPosition * x.size : 0\n    const yRootPosition = yGraduations === 1 ? y.rootPosition * y.size : 0\n\n    const xProgress = x.progress * 2\n    const yProgress = y.progress * 2\n\n    let index = 0\n\n    for (var i = 0; i < xGraduations; i++) {\n      const position = i * xFactor - xHalfSize + xRootPosition\n\n      vertices[index     ] = vertices[index +  9] = position - xHalfLineWidth\n      vertices[index +  3] = vertices[index +  6] = position + xHalfLineWidth\n      vertices[index +  7] = vertices[index + 10] = -yHalfOuterSize\n      vertices[index +  1] = vertices[index +  4] = -yHalfOuterSize + (\n        yHalfOuterSize * xProgress\n      )\n\n      index += 12\n    }\n\n    for (var i = 0; i < yGraduations; i++) {\n      const position = i * yFactor - yHalfSize + yRootPosition\n\n      vertices[index + 7] = vertices[index + 10] = position - yHalfLineWidth\n      vertices[index + 1] = vertices[index +  4] = position + yHalfLineWidth\n      vertices[index    ] = vertices[index +  9] = -xHalfOuterSize\n      vertices[index + 3] = vertices[index +  6] = -xHalfOuterSize + (\n        xHalfOuterSize * yProgress\n      )\n\n      index += 12\n    }\n\n    positionAttribute.needsUpdate = true\n  }\n}\n","import { Box2, Vector2 } from 'three'\nimport { Axis } from '~/axis'\n\nexport class Container extends Box2 {\n  private readonly _size: Vector2 = new Vector2()\n\n  public constructor(points?: ({ x: number, y: number })[]) {\n    super()\n\n    if (points) {\n      const pointValues = points.map(({ x, y }, index) => {\n        const pointValue = {\n          x: parseFloat(x as unknown as string),\n          y: parseFloat(y as unknown as string)\n        }\n\n        if (isNaN(pointValue.x)) pointValue.x = index / (points.length - 1)\n        if (isNaN(pointValue.y)) pointValue.y = index / (points.length - 1)\n\n        return pointValue\n      })\n\n      this.setFromPoints(pointValues as Vector2[])\n    }\n  }\n\n  public get size(): Vector2 {\n    return this.getSize(this._size)\n  }\n\n  public normalizePoint(\n    point: { x: number, y: number },\n    target: Vector2 = new Vector2()\n  ): Vector2 {\n    return target\n      .subVectors(point as Vector2, this.min)\n      .divide(this.size)\n  }\n\n  public interpolatePoint(\n    point: { x: number, y: number },\n    container?: Container,\n    target: Vector2 = new Vector2()\n  ): Vector2 {\n    return (container ? container.normalizePoint(point, target) : target)\n      .multiply(this.size)\n      .add(this.min)\n  }\n\n  public interpolatePoints(\n    points: ({ x: number, y: number })[],\n    targets: Vector2[] = points.map(() => new Vector2())\n  ): Vector2[] {\n    const container = new Container(points)\n\n    points.some((point, index) => {\n      if (index >= targets.length) return true\n\n      const pointValue = {\n        x: parseFloat(point.x as unknown as string),\n        y: parseFloat(point.y as unknown as string)\n      }\n\n      if (isNaN(pointValue.x)) {\n        pointValue.x = index / (points.length - 1)\n      }\n\n      if (isNaN(pointValue.y)) {\n        pointValue.y = index / (points.length - 1)\n      }\n\n      this.interpolatePoint(pointValue, container, targets[index])\n    })\n\n    return targets\n  }\n\n  public resize(x: Axis, y: Axis): void {\n    const xHalfSize = x.size / 2\n    const yHalfSize = y.size / 2\n\n    this.min.set(\n      x.startOffset * x.size - xHalfSize,\n      y.startOffset * y.size - yHalfSize\n    )\n\n    this.max.set(\n      xHalfSize - x.endOffset * x.size,\n      yHalfSize - y.endOffset * y.size\n    )\n  }\n}\n","import { Mesh, MeshBasicMaterial, Color, Vector2 } from 'three'\nimport { Axis, AxisParameters, AxisGenerateParameters } from '~/axis'\nimport { Labels, LabelsParameters } from '~/labels'\nimport { Graduations } from '~/graduations'\nimport { Container } from '~/container'\n\nexport class Axes extends Mesh {\n  public x: Axis\n  public y: Axis\n  public labels: Labels\n  public graduations: Graduations\n  public container: Container = new Container()\n\n  public constructor({\n    x = {},\n    y = {},\n    labels = {},\n    opacity = 1,\n    color = 0xffffff,\n    generate = true\n  }: {\n    x?: Partial<AxisParameters>\n    y?: Partial<AxisParameters>\n    labels?: Partial<LabelsParameters>\n    opacity?: number\n    color?: Color | number | string\n    generate?: boolean\n  } = {}) {\n    super(new Graduations())\n\n    this.x = new Axis({ ...x,\n      orientation: new Vector2(1, 0),\n      spacing: new Vector2(1, -1)\n    })\n\n    this.y = new Axis({ ...y,\n      orientation: new Vector2(0, 1),\n      spacing: new Vector2(-1, 1)\n    })\n\n    this.graduations = this.geometry as Graduations\n    this.labels = new Labels(labels)\n    this.opacity = opacity\n    this.color.set(color as Color)\n\n    this.add(this.labels)\n\n    generate && this.generate()\n  }\n\n  public get visible(): boolean {\n    return this.labels.visible\n  }\n\n  public set visible(visible: boolean) {\n    if (this.labels) this.labels.visible = visible\n  }\n\n  public get color(): Color {\n    return (this.material as MeshBasicMaterial).color\n  }\n\n  public set color(color: Color) {\n    (this.material as MeshBasicMaterial).color = color\n  }\n\n  public get opacity(): number {\n    return (this.material as MeshBasicMaterial).opacity\n  }\n\n  public set opacity(opacity: number) {\n    (this.material as MeshBasicMaterial).transparent = opacity !== 1\n    ;(this.material as MeshBasicMaterial).opacity = opacity\n  }\n\n  public generate(\n    values?: ({ x: number | string, y: number | string })[],\n    { x = {}, y = {} }: {\n      x?: Partial<AxisGenerateParameters>\n      y?: Partial<AxisGenerateParameters>\n    } = {}\n  ): void {\n    if (values) {\n      const xLabels = values.map(({ x }) => x)\n      const yLabels = values.map(({ y }) => y)\n\n      const xValues = (xLabels as string[]).map(parseFloat)\n      const yValues = (yLabels as string[]).map(parseFloat)\n\n      if (xValues.includes(NaN)) this.x.labels = xLabels\n      else this.x.generate(xValues, x)\n\n      if (yValues.includes(NaN)) this.y.labels = yLabels\n      else this.y.generate(yValues, y)\n    }\n\n    this.generateGraduations()\n    this.generateLabels()\n  }\n\n  public resize(): void {\n    this.resizeGraduations()\n    this.resizeLabels()\n  }\n\n  public generateGraduations(): void {\n    this.graduations.generate(this.x, this.y)\n    this.container.resize(this.x, this.y)\n  }\n\n  public resizeGraduations(): void {\n    this.graduations.resize(this.x, this.y)\n    this.container.resize(this.x, this.y)\n  }\n\n  public generateLabels(): void {\n    this.labels.generate(this.x, this.y)\n  }\n\n  public resizeLabels(): void {\n    this.labels.resize(this.x, this.y)\n  }\n}\n"],"names":["_a","orientation","spacing","_b","size","_c","labels","_d","prefix","_e","suffix","_f","decimals","_g","graduations","_h","root","_j","relative","_k","lineWidth","_l","progress","_m","margin","_o","padding","_p","distance","this","_labels","Axis","number","i","s","Math","sqrt","delta","minimumDelta","range","targetDensity","halfRange","max","length","index","findIndex","label","parseFloat","rootPosition","Object","updateRootPosition","_relative","values","rounding","avoidPrime","includeZero","autoRelative","minimumOffset","maximumOffset","endOffset","minimum","Infinity","maximum","baseDelta","startOffset","value","otherValue","valueDelta","shiftedMinimum","round","baseAmount","amount","isPrime","relativeOffset","abs","splice","tslib_1.__extends","createElement","_this","document","content","wrapper","appendChild","__extends","generate","axis","renderingScale","oppositeRelative","opposite","position","spacingX","x","spacingY","y","style","call","CSS3DRenderer","Matrix4","opacity","color","fontSize","fontFamily","faceCamera","matrixAutoUpdate","pointerEvents","_super","iterate","reduce","callback","axes","width","render","parent","xCamera","camera","yCamera","zCamera","z","originalMatrix","applyMatrix","updateWorldMatrix","children","forEach","updateMatrix","updateMatrixWorld","matrix","copy","scaleFont","add","indices","setIndex","three","setAttribute","positionAttribute","vertices","xGraduations","yGraduations","xHalfSize","yHalfSize","xFactor","yFactor","xHalfPaddedSize","yHalfPaddedSize","xHalfLineWidth","yHalfLineWidth","xHalfOuterSize","yHalfOuterSize","xRootPosition","yRootPosition","xProgress","yProgress","points","pointValue","isNaN","subVectors","point","Vector2","multiply","targets","resize","min","set","Graduations","container","geometry","material","transparent","xValues","xLabels","map","yValues","generateGraduations","resizeGraduations","generateLabels","resizeLabels"],"mappings":"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"}