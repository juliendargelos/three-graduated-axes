{"version":3,"file":"index.umd.js","sources":["../src/axis.ts","../src/css-style.ts","../src/label.ts","../src/labels.ts","../src/graduations.ts","../src/axes.ts"],"sourcesContent":["import { Vector2 } from 'three'\n\nexport interface AxisParameters {\n  size: number\n  labels: (number | string)[]\n  decimals?: number\n  prefix: string\n  suffix: string\n  graduations: number\n  root: boolean\n  relative: boolean\n  lineWidth: number\n  progress: number\n  margin: number\n  padding: number\n}\n\nexport interface AxisGenerateParameters {\n  targetDensity: number\n  minimumDelta: number\n  rounding: number\n  avoidPrime: boolean\n  includeZero: boolean\n  autoRelative: boolean\n  symmetric: boolean\n}\n\nexport class Axis implements AxisParameters {\n  private _relative!: boolean\n  private _labels!: (number | string)[]\n  public orientation: Vector2\n  public spacing: Vector2\n  public size: number\n  public decimals?: number\n  public prefix: string\n  public suffix: string\n  public graduations: number\n  public root: boolean\n  public lineWidth: number\n  public progress: number\n  public margin: number\n  public padding: number\n  public rootPosition!: number\n  public startOffset: number = 0\n  public endOffset: number = 0\n\n  public constructor({\n    orientation,\n    spacing,\n    size = 10,\n    labels = [],\n    prefix = '',\n    suffix = '',\n    decimals = undefined,\n    graduations = 1,\n    root = false,\n    relative = false,\n    lineWidth = 0.02,\n    progress = 1,\n    margin = 0.2,\n    padding = 0\n  }: Partial<AxisParameters> & {\n    orientation: Vector2\n    spacing: Vector2\n  }) {\n    this.orientation = orientation\n    this.spacing = spacing\n    this.size = size\n    this._labels = labels\n    this.prefix = prefix\n    this.suffix = suffix\n    this.decimals = decimals\n    this.graduations = graduations\n    this.root = root\n    this.relative = relative\n    this.lineWidth = lineWidth\n    this.progress = progress\n    this.margin = margin\n    this.padding = padding\n  }\n\n  private isPrime(number: number): boolean {\n    for (var i = 2, s = Math.sqrt(number); i <= s; i++) {\n      if (number % i === 0) return false\n    }\n\n    return number > 1\n  }\n\n  private updateRootPosition(): void {\n    if (!this.relative) {\n      this.rootPosition = 0\n    } else if (!this.labels.length) {\n      this.rootPosition = 0.5\n    } else {\n      const index = this.labels.findIndex(label => (\n        parseFloat(label as string) === 0\n      ))\n\n      this.rootPosition = index === -1\n        ? 0\n        : index / (this.labels.length - 1)\n    }\n  }\n\n  public get labels(): (number | string)[] {\n    return this._labels\n  }\n\n  public set labels(labels: (number | string)[]) {\n    this._labels = labels\n    this.updateRootPosition()\n  }\n\n  public get relative(): boolean {\n    return this._relative\n  }\n\n  public set relative(relative: boolean) {\n    this._relative = relative\n    this.updateRootPosition()\n  }\n\n  public generate(values: number[], {\n    targetDensity = 4,\n    minimumDelta = 1,\n    rounding = 2,\n    avoidPrime = true,\n    includeZero = false,\n    autoRelative = true,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    symmetric = false // TODO\n  }: Partial<AxisGenerateParameters> = {}): void {\n    this.reset()\n\n    const firstValue = values[0]\n\n    let minimum = Infinity\n    let maximum = -Infinity\n    let delta = Infinity\n    let startOffset = 0\n    let endOffset = 0\n    let round = (value: number): number => value\n\n    values.forEach((value) => {\n      if (value < minimum) minimum = value\n      if (value > maximum) maximum = value\n      const valueDelta = Math.abs(value - firstValue)\n      if (valueDelta && valueDelta < delta) delta = valueDelta\n    })\n\n    if (autoRelative) this.relative = minimum < 0 && maximum > 0\n\n    let range = maximum - minimum\n    delta = Math.max(minimumDelta, delta)\n    delta = delta * (range / delta / targetDensity)\n\n    if (delta >= range / 2) delta = range / 2\n\n    if (rounding) {\n      const roundingFactor = Math.pow(10, rounding)\n      round = (value: number) => Math.round(\n        value * roundingFactor\n      ) / roundingFactor\n\n      delta = round(delta)\n\n      const shiftedMinimum = Math.floor(\n        minimum * roundingFactor\n      ) / roundingFactor\n\n      startOffset += minimum - shiftedMinimum\n\n      minimum = shiftedMinimum\n      range += startOffset\n    }\n\n    const amount = range / delta + 1\n    let shiftedAmount = Math.ceil(amount)\n\n    if (avoidPrime) {\n      while (this.isPrime(shiftedAmount + 1)) shiftedAmount++\n    }\n\n    endOffset = (shiftedAmount - amount) * delta || 0\n    maximum += endOffset\n    range += endOffset\n\n    if (includeZero || (autoRelative && this.relative)) {\n      let relativeOffset = Infinity\n\n      for (var i = 0; relativeOffset && i < shiftedAmount; i++) {\n        const value = minimum + i * delta\n\n        if (Math.abs(value) < Math.abs(relativeOffset)) {\n          relativeOffset = value\n        }\n      }\n\n      if (relativeOffset < 0) relativeOffset += delta\n\n      minimum -= relativeOffset\n      startOffset += relativeOffset\n      range += relativeOffset\n    }\n\n    const labels: number[] = []\n\n    for (var i = 0; i < shiftedAmount; i++) {\n      labels.push(round(minimum + i * delta))\n    }\n\n    this.startOffset = startOffset / range\n    this.endOffset = endOffset / range\n    this.labels = labels\n  }\n\n  public reset(): void {\n    this.startOffset = this.endOffset = 0\n    this.labels.splice(0)\n    this.graduations = 1\n    this.root = false\n    this.relative = false\n  }\n}\n","export class CSSStyle {\n  private readonly id = `${Date.now()}-${~~(Math.random() * 1000)}`\n\n  private property(name: string): string {\n    return `--${name}-${this.id}`\n  }\n\n  public get(property: string): string {\n    return document.body.style.getPropertyValue(this.property(property))\n  }\n\n  public set(property: string, value: string): this {\n    document.body.style.setProperty(this.property(property), value)\n    return this\n  }\n\n  public bind(style: CSSStyleDeclaration, ...properties: string[]): void {\n    properties.forEach(property => {\n      style.setProperty(property, `var(${this.property(property)})`)\n    })\n  }\n}\n","import { CSS3DObject } from 'three/examples/jsm/renderers/CSS3DRenderer'\nimport { Axis } from '~/axis'\n\nexport class Label extends CSS3DObject {\n  private readonly wrapper: HTMLDivElement = document.createElement('div')\n  private readonly content: HTMLDivElement = document.createElement('div')\n\n  public constructor() {\n    super(document.createElement('div'))\n    this.wrapper.appendChild(this.content)\n    this.element.appendChild(this.wrapper)\n  }\n\n  public get style(): CSSStyleDeclaration {\n    return this.wrapper.style\n  }\n\n  public generate(axis: Axis, value: number | string): void {\n    const rounding = (\n      axis.decimals !== undefined &&\n      Math.pow(10, axis.decimals)\n    ) as number\n\n    this.content.textContent = `${axis.prefix}${\n      rounding ? Math.round((value as number) * rounding) / rounding : value\n    }${axis.suffix}`\n  }\n\n  public resize(\n    axis: Axis,\n    opposite: Axis,\n    position: number,\n    renderingScale: number = 10\n  ): void {\n    const rootPosition = (opposite.rootPosition - 0.5) * opposite.size\n    position = (position / (axis.labels.length - 1) - 0.5) * axis.size\n\n    const spacingX = axis.spacing.x * (\n      (opposite.relative || !axis.orientation.x) as unknown as number\n    )\n\n    const spacingY = axis.spacing.y * (\n      (opposite.relative || !axis.orientation.y) as unknown as number\n    )\n\n    this.content.style.transform = `translate(${\n      50 * spacingX\n    }%, ${\n      -50 * spacingY\n    }%)`\n\n    this.position\n      .setX(renderingScale * (\n        axis.orientation.x * position +\n        axis.orientation.y * rootPosition +\n        axis.margin * spacingX -\n        axis.padding * axis.orientation.y * (\n          !opposite.relative as unknown as number\n        )\n      ))\n      .setY(renderingScale * (\n        axis.orientation.y * position +\n        axis.orientation.x * rootPosition +\n        axis.margin * spacingY -\n        axis.padding * axis.orientation.x * (\n          !opposite.relative as unknown as number\n        )\n      ))\n  }\n}\n","import {\n  Object3D,\n  WebGLRenderer,\n  Camera,\n  Scene,\n} from 'three'\n\nimport { CSSStyle } from '~/css-style'\nimport { Axis } from '~/axis'\nimport { Label } from '~/label'\n\nexport interface LabelsParameters {\n  opacity: number\n  color: string\n  fontSize: number\n  fontFamily: string\n  faceCamera: boolean\n  renderingScale: number\n}\n\nexport class Labels extends Object3D implements LabelsParameters {\n  private readonly cssStyle = new CSSStyle().set('white-space', 'nowrap')\n  private _faceCamera!: boolean\n  public fontSize: number\n  public renderingScale: number\n\n  public constructor({\n    opacity = 1,\n    color = '#aaaaaa',\n    fontSize = 0.3,\n    fontFamily = 'sans-serif',\n    faceCamera = false,\n    renderingScale = 100,\n  }: Partial<LabelsParameters> = {}) {\n    super()\n\n    this.opacity = opacity\n    this.color = color\n    this.fontSize = fontSize\n    this.fontFamily = fontFamily\n    this.faceCamera = faceCamera\n    this.renderingScale = renderingScale\n  }\n\n  private iterate(x: Axis, y: Axis, callback: (\n    axis: Axis,\n    opposite: Axis,\n    index: number,\n    position: number,\n    value: number | string\n  ) => void): number {\n    return [x, y].reduce((index, axis, axisIndex, axes) => {\n      return axis.labels.reduce((index: number, value, position) => {\n        callback(\n          axis,\n          axes[(axisIndex + 1) % axes.length],\n          index,\n          position,\n          value\n        )\n\n        return index + 1\n      }, index)\n    }, 0)\n  }\n\n  private addLabel(): Label {\n    const label = new Label()\n\n    this.cssStyle.bind(label.style,\n      'opacity',\n      'color',\n      'visibility',\n      'white-space',\n      'transform',\n      'font-size',\n      'font-family'\n    )\n\n    this.add(label)\n    return label\n  }\n\n  private scaleFont(): void {\n    this.cssStyle.set('font-size', `${this.fontSize * this.renderingScale}px`)\n  }\n\n  public get opacity(): number {\n    return parseFloat(this.cssStyle.get('opacity'))\n  }\n\n  public set opacity(opacity: number) {\n    this.cssStyle.set('opacity', opacity as unknown as string)\n  }\n\n  public get color(): string {\n    return this.cssStyle.get('color')\n  }\n\n  public set color(color: string) {\n    this.cssStyle.set('color', color)\n  }\n\n  public get fontFamily(): string {\n    return this.cssStyle.get('font-family')\n  }\n\n  public set fontFamily(fontFamily: string) {\n    this.cssStyle.set('font-family', fontFamily)\n  }\n\n  public get faceCamera(): boolean {\n    return this._faceCamera\n  }\n\n  public set faceCamera(faceCamera: boolean) {\n    this._faceCamera = faceCamera\n    faceCamera || this.children.forEach(label => label.rotation.set(0, 0, 0))\n  }\n\n  public get visible(): boolean {\n    return this.cssStyle && this.cssStyle.get('visibility') !== 'hidden'\n  }\n\n  public set visible(visible: boolean) {\n    this.cssStyle && this.cssStyle.set('visibility',\n      visible ? 'visible' : 'hidden'\n    )\n  }\n\n  public onBeforeRender = (_: WebGLRenderer, __: Scene, camera: Camera) => {\n    camera.position.multiplyScalar(this.renderingScale)\n\n    this.faceCamera && this.children.forEach(label => {\n      label.lookAt(camera.position)\n    })\n  }\n\n  public onAfterRender = (_: WebGLRenderer, __: Scene, camera: Camera) => {\n    camera.position.divideScalar(this.renderingScale)\n  }\n\n  public generate(x: Axis, y: Axis): void {\n    this.scaleFont()\n\n    this.children\n      .slice(this.iterate(x, y, (axis, opposite, index, position, value) => {\n        const label = (this.children[index] as Label) || this.addLabel()\n        label.generate(axis, value)\n        label.resize(axis, opposite, position, this.renderingScale)\n      }))\n      .forEach(label => this.remove(label))\n  }\n\n  public resize(x: Axis, y: Axis): void {\n    this.scaleFont()\n\n    this.iterate(x, y, (axis, opposite, index, position) => {\n      const label = this.children[index] as Label\n      label && label.resize(axis, opposite, position, this.renderingScale)\n    })\n  }\n}\n","import { BufferGeometry, BufferAttribute, Box2, Vector2 } from 'three'\nimport { Axis } from '~/axis'\n\nexport class Graduations extends BufferGeometry {\n  private graduations: number[] = []\n  public readonly container: Box2 = new Box2(new Vector2(), new Vector2())\n\n  public generate(x: Axis, y: Axis): void {\n    const indicesLength = 6 * [x, y].reduce((sum, {\n      graduations,\n      root,\n      rootPosition,\n      labels\n    }, index) => {\n      const maximum = labels.length - 1\n\n      if (!graduations) {\n        graduations = 0 + (root as unknown as number)\n      } else if (labels.length) {\n        if (graduations < 1) {\n          rootPosition *= maximum\n          let step = Math.min(maximum, Math.round(1 / graduations))\n          while (maximum % step || rootPosition % step) step--\n          graduations = Math.ceil(labels.length / step)\n        } else {\n          graduations = Math.round(graduations) * maximum + 1\n        }\n      } else {\n        graduations = Math.round(graduations)\n      }\n\n      this.graduations[index] = graduations\n\n      return sum + graduations\n    }, 0)\n\n    const indices = new Uint16Array(indicesLength)\n    let index = 0\n\n    for (var i = 0; i < indicesLength; i += 6) {\n      indices[i    ] = indices[i + 3] = index\n      indices[i + 1] = indices[i + 5] = index + 2\n      indices[i + 2] = index + 1\n      indices[i + 4] = index + 3\n\n      index += 4\n    }\n\n    this.setIndex(new BufferAttribute(indices, 1))\n    this.setAttribute('position',\n      new BufferAttribute(new Float32Array(indicesLength * 2), 3)\n    )\n\n    this.resize(x, y)\n  }\n\n  public resize(x: Axis, y: Axis): void {\n    const positionAttribute = this.getAttribute('position') as BufferAttribute\n    const vertices = positionAttribute.array as Float32Array\n\n    const xGraduations = this.graduations[0]\n    const yGraduations = this.graduations[1]\n\n    const xHalfSize = x.size / 2\n    const yHalfSize = y.size / 2\n\n    const xFactor = x.size / Math.max(1, xGraduations - 1)\n    const yFactor = y.size / Math.max(1, yGraduations - 1)\n\n    const xPaddedHalfSize = xHalfSize + y.padding\n    const yPaddedHalfSize = yHalfSize + x.padding\n\n    const xHalfLineWidth = x.lineWidth / 2\n    const yHalfLineWidth = y.lineWidth / 2\n\n    const xRootPosition = xGraduations === 1 ? x.rootPosition * x.size : 0\n    const yRootPosition = yGraduations === 1 ? y.rootPosition * y.size : 0\n\n    const xProgress = x.progress * 2\n    const yProgress = y.progress * 2\n\n    let index = 0\n\n    for (var i = 0; i < xGraduations; i++) {\n      const position = i * xFactor - xHalfSize + xRootPosition\n\n      vertices[index    ] = vertices[index +  9] = position - xHalfLineWidth\n      vertices[index + 3] = vertices[index +  6] = position + xHalfLineWidth\n      vertices[index + 7] = vertices[index + 10] = -yPaddedHalfSize\n      vertices[index + 1] = vertices[index +  4] = (\n        yPaddedHalfSize * xProgress - yPaddedHalfSize\n      )\n\n      index += 12\n    }\n\n    for (var i = 0; i < yGraduations; i++) {\n      const position = i * yFactor - yHalfSize + yRootPosition\n\n      vertices[index + 7] = vertices[index + 10] = position - yHalfLineWidth\n      vertices[index + 1] = vertices[index +  4] = position + yHalfLineWidth\n      vertices[index    ] = vertices[index +  9] = -xPaddedHalfSize\n      vertices[index + 3] = vertices[index +  6] = (\n        xPaddedHalfSize * yProgress - xPaddedHalfSize\n      )\n\n      index += 12\n    }\n\n    positionAttribute.needsUpdate = true\n\n    this.container.min.set(\n      x.startOffset * x.size - xHalfSize,\n      y.startOffset * y.size - yHalfSize\n    )\n\n    this.container.max.set(\n      xHalfSize - x.endOffset * x.size,\n      yHalfSize - y.endOffset * y.size\n    )\n  }\n}\n","import {\n  Mesh,\n  MeshBasicMaterial,\n  WebGLRenderer,\n  Camera,\n  Scene,\n  Color,\n  Vector2\n} from 'three'\n\nimport { CSS3DRenderer } from 'three/examples/jsm/renderers/CSS3DRenderer'\nimport { Axis, AxisParameters, AxisGenerateParameters } from '~/axis'\nimport { Labels, LabelsParameters } from '~/labels'\nimport { Graduations } from '~/graduations'\n\nexport class Axes extends Mesh {\n  public x: Axis\n  public y: Axis\n  public labels: Labels\n  public graduations: Graduations\n\n  public constructor({\n    x = {},\n    y = {},\n    labels = {},\n    opacity = 1,\n    color = 0xaaaaaa,\n    autoRenderCSS3D = true\n  }: {\n    x?: Partial<AxisParameters>\n    y?: Partial<AxisParameters>\n    labels?: Partial<LabelsParameters>\n    opacity?: number\n    color?: Color | number | string\n    autoRenderCSS3D?: boolean | Scene\n  } = {}) {\n    super(new Graduations())\n\n    this.x = new Axis({ ...x,\n      orientation: new Vector2(1, 0),\n      spacing: new Vector2(1, -1)\n    })\n\n    this.y = new Axis({ ...y,\n      orientation: new Vector2(0, 1),\n      spacing: new Vector2(-1, 1)\n    })\n\n    this.graduations = this.geometry as Graduations\n    this.labels = new Labels(labels)\n    this.opacity = opacity\n    this.color.set(color as Color)\n\n    this.add(this.labels)\n\n    autoRenderCSS3D && this.autoRenderCSS3D(autoRenderCSS3D === true\n      ? this as unknown as Scene\n      : autoRenderCSS3D\n    )\n\n    this.generate()\n  }\n\n  public get visible(): boolean {\n    return this.labels.visible\n  }\n\n  public set visible(visible: boolean) {\n    if (this.labels) this.labels.visible = visible\n  }\n\n  public get color(): Color {\n    return (this.material as MeshBasicMaterial).color\n  }\n\n  public set color(color: Color) {\n    (this.material as MeshBasicMaterial).color = color\n  }\n\n  public get opacity(): number {\n    return (this.material as MeshBasicMaterial).opacity\n  }\n\n  public set opacity(opacity: number) {\n    (this.material as MeshBasicMaterial).transparent = opacity !== 1\n    ;(this.material as MeshBasicMaterial).opacity = opacity\n  }\n\n  public onBeforeRender = (\n    renderer: WebGLRenderer,\n    scene: Scene,\n    camera: Camera\n  ) => this.labels.onBeforeRender(renderer, scene, camera)\n\n  public onAfterRender = (\n    renderer: WebGLRenderer,\n    scene: Scene,\n    camera: Camera\n  ) => this.labels.onAfterRender(renderer, scene, camera)\n\n  public generate(values?: ({ x: number, y: number })[], { x = {}, y = {} }: {\n    x?: Partial<AxisGenerateParameters>\n    y?: Partial<AxisGenerateParameters>\n  } = {}): void {\n    if (values) {\n      this.x.generate(values.map(({ x }) => x), x)\n      this.y.generate(values.map(({ y }) => y), y)\n    }\n\n    this.generateGraduations()\n    this.generateLabels()\n  }\n\n  public resize(): void {\n    this.resizeGraduations()\n    this.resizeLabels()\n  }\n\n  public generateGraduations(): void {\n    this.graduations.generate(this.x, this.y)\n  }\n\n  public resizeGraduations(): void {\n    this.graduations.resize(this.x, this.y)\n  }\n\n  public generateLabels(): void {\n    this.labels.generate(this.x, this.y)\n  }\n\n  public resizeLabels(): void {\n    this.labels.resize(this.x, this.y)\n  }\n\n  public autoRenderCSS3D(scene: Scene): void {\n    const onAfterRender = this.onAfterRender\n    const css3DRenderer = new CSS3DRenderer()\n    const rendererSize = new Vector2()\n\n    css3DRenderer.domElement.style.position = 'absolute'\n    css3DRenderer.domElement.style.pointerEvents = 'none'\n    css3DRenderer.domElement.style.top =\n    css3DRenderer.domElement.style.left = '0'\n    css3DRenderer.domElement.style.zIndex = '2'\n\n    scene.onAfterRender = (\n      renderer: WebGLRenderer,\n      scene: Scene,\n      camera: Camera,\n    ) => {\n      renderer.getSize(rendererSize)\n      css3DRenderer.setSize(rendererSize.x, rendererSize.y)\n      css3DRenderer.render(scene, camera)\n      onAfterRender(renderer, scene, camera)\n    }\n\n    document.body.appendChild(css3DRenderer.domElement)\n  }\n\n  public interpolateValue(\n    value: number,\n    minimum: number,\n    maximum: number,\n    axis: 'x' | 'y'\n  ): number {\n    return (value - minimum) / (maximum - minimum) * (\n      this.graduations.container.max[axis] -\n      this.graduations.container.min[axis]\n    ) + this.graduations.container.min[axis]\n  }\n\n  public interpolate(\n    values: ({ x: number, y: number })[],\n    points: Vector2[] = []\n  ): Vector2[] {\n\n    points.length > values.length && points.splice(values.length)\n    while (points.length < values.length) points.push(new Vector2())\n\n    let xMinimum = Infinity\n    let yMinimum = Infinity\n\n    let xMaximum = -Infinity\n    let yMaximum = -Infinity\n\n    values.forEach(({ x, y }) => {\n      if (x < xMinimum) xMinimum = x\n      if (x > xMaximum) xMaximum = x\n      if (y < yMinimum) yMinimum = y\n      if (y > yMaximum) yMaximum = y\n    })\n\n    values.forEach(({ x, y }, index) => points[index].set(\n      this.interpolateValue(x, xMinimum, xMaximum, 'x'),\n      this.interpolateValue(y, yMinimum, yMaximum, 'y')\n    ))\n\n    return points\n  }\n}\n"],"names":["_a","orientation","spacing","_b","size","_c","labels","_d","prefix","_e","suffix","_f","decimals","_g","graduations","_h","root","_j","relative","_k","lineWidth","_l","progress","_m","margin","_o","padding","this","_labels","Axis","number","i","s","Math","sqrt","length","index","findIndex","label","parseFloat","rootPosition","Object","updateRootPosition","_relative","values","targetDensity","minimumDelta","rounding","avoidPrime","includeZero","autoRelative","endOffset","firstValue","minimum","Infinity","maximum","delta","startOffset","value","valueDelta","max","range","round","shiftedMinimum","amount","shiftedAmount","relativeOffset","abs","CSSStyle","get","property","document","tslib_1.__extends","createElement","_this","content","wrapper","appendChild","__extends","generate","axis","renderingScale","opposite","position","spacingX","x","spacingY","y","style","camera","multiplyScalar","_","opacity","color","fontSize","fontFamily","faceCamera","_super","iterate","reduce","callback","axes","cssStyle","bind","scaleFont","children","indices","setIndex","three","setAttribute","positionAttribute","vertices","xGraduations","yGraduations","xHalfSize","yHalfSize","xFactor","yFactor","xPaddedHalfSize","yPaddedHalfSize","xHalfLineWidth","yHalfLineWidth","xRootPosition","yRootPosition","xProgress","yProgress","needsUpdate","container","min","set","onAfterRender","renderer","scene","Vector2","geometry","autoRenderCSS3D","material","transparent","generateGraduations","resizeGraduations","generateLabels","resizeLabels","css3DRenderer","CSS3DRenderer","domElement","pointerEvents","setSize","render","points","xMinimum","yMinimum","xMaximum"],"mappings":"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"}